const HtmlComponent = Formio.Components.components.htmlelement; class MapComponent extends HtmlComponent { constructor(e, t, r) { super(e, t, r), this.markers = [], this.mapId = this.id } get HtmlComponentInfo() { try { return super.HtmlComponentInfo } catch (e) { console.error(e) } } init() { try { super.init() } catch (e) { console.error(e) } } renderContent() { try { return `<div ref="customRef" id="map-${this.mapId}" class="formio-map"></div>` } catch (e) { console.error(e) } } async attach(e) { try { let t = null; return this.#e() || (this.#t(), this.#r()), this.#a() || (t = this.#o()), this.loadRefs(e, { customRef: "single" }), null != t ? await new Promise(((e, r) => { t.addEventListener("load", (() => { this.#s(), e() }), !1) })).catch((e => { console.error("Unhandled error ", e) })) : this.#s(), super.attach(e) } catch (e) { console.error(e) } } #s() { try { this.#n(), navigator.geolocation && navigator.geolocation.getCurrentPosition((e => { var t = e?.coords?.latitude, r = e?.coords?.longitude; t && r && setTimeout((() => { this.#n(), this.map.setView([t, r], 17), L.popup().setLatLng([t, r]).setContent("Your current location").openOn(this.map) }), 2e3) })) } catch (e) { console.error(e) } } #n() { if (!this.map && (this.map = L.map(`map-${this.mapId}`).setView([6.131944, 1.222778], 17), L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>' }).addTo(this.map), this.#i(), this.map.on("click", this.#l.bind(this)), this.markers.length)) { const e = [...this.markers]; this.markers.length = 0, e.forEach((e => { this.#c(e._latlng.lat, e._latlng.lng, e.isStrategic ?? !1, !0, !0) })), this.dataValue = this.#h(this.markers), this.triggerChange() } } detach() { try { return this.map = null, super.detach() } catch (e) { console.error(e) } } destroy() { try { return this.map = null, this.markers = [], super.destroy() } catch (e) { console.error(e) } } normalizeValue(e, t = {}) { try { return super.normalizeValue(e, t) } catch (e) { console.error(e) } } getValue() { try { return this.markers } catch (e) { console.error(e) } } getValueAt(e) { try { return this.markers[e] } catch (e) { console.error(e) } return super.getValueAt(e) } setValue(e, t = {}) { try { if (!e) return !1; if (this.dataValue = e, 0 == this.markers.length && Array.isArray(e) && this.markers.push(...this.#m(e)), this.markers.forEach((e => { e.addTo(this.map) })), this.dataValue.length >= 2) { let e = this.dataValue.filter((e => !e.isStrategic)); e.length >= 3 && (e = [...e, e[0]]), this.#p(); const t = e.map((e => new L.LatLng(e.lat, e.lng))); this.polyline = new L.Polyline(t, { color: "red", weight: 2, opacity: 1, smoothFactor: 2 }).addTo(this.map), e.length >= 3 && (this.polygon = new L.polygon(t, { color: "blue", weight: 1, opacity: .25 }).addTo(this.map)) } else this.#p(); return this.refs = this.refs || {}, this.refs.input = this.refs.input || [], this.root && this.triggerChange(), super.setValue(e, t) } catch (e) { console.error(e) } } setValueAt(e, t, r = {}) { try { return super.setValueAt(e, t, r) } catch (e) { return console.error(e), !1 } } updateValue(e, t = {}) { try { return !0 } catch (e) { return console.error(e), !1 } } isValid(e, t) { return console.error("Component is invalid ", e, t), super.isValid(e, t) } validate() { this.component; return 0 == this.markers.length ? Promise.reject("You must add at least one marker") : Promise.resolve(!0) } #l(e) { try { this.#c(e.latlng.lat, e.latlng.lng, e.isStrategic ?? !1, !1); this.setValue(this.#h(this.markers)) } catch (e) { console.error(e) } } #h(e) { try { return this.markers.map((e => ({ lat: e._latlng.lat, lng: e._latlng.lng }))) } catch (e) { console.error(e) } } #m(e) { try { if (this.#n(), !Array.isArray(e)) throw new Error("Array is required"); return e.map((e => this.#c(e.lat, e.lng, e.isStrategic ?? !1, !1))) } catch (e) { return console.error(e), [] } } #e() { try { return null !== document.querySelector('link[href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"][async= "false"]') } catch (e) { console.error(e) } } #a() { try { return null !== document.querySelector('script[src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"][async= "false"]') } catch (e) { console.error(e) } } #t() { try { const e = document.createElement("link"); e.rel = "stylesheet", e.href = "https://unpkg.com/leaflet@1.9.4/dist/leaflet.css", e.setAttribute("async", "false"), document.head.appendChild(e) } catch (e) { console.error(e) } } #o() { try { const e = document.createElement("script"); e.setAttribute("src", "https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"), e.setAttribute("async", "false"); let t = document.head; return t.insertBefore(e, t.firstChild), e } catch (e) { console.error(e) } } #r() { try { var e = document.createElement("style"); e.textContent = ".formio-map { height: 280px; border-radius: 20px; overflow: hidden; }", document.head.appendChild(e) } catch (e) { console.error(e) } } #i() { this.redMarker = L.icon({ iconUrl: "https://assets-1fdf5.kxcdn.com/NIMBLE/img/pin.png", iconAnchor: [13, 41] }) } #c(e, t, r, a = !1, o = !0) { try { let s = {}; r || (s = { icon: this.redMarker }); const n = L.marker([e, t], s); if (a && n.addTo(this.map), n.on("click", (() => this.#u(n))), o) try { this.validate(), this.markers.push(n) } catch (e) { console.error("Validation Error: ", e) } return n } catch (e) { console.error(e) } } #u(e) { try { this.map.removeLayer(e); const t = this.markers.indexOf(e); -1 !== t && this.markers.splice(t, 1), this.setValue(this.#h(this.markers)) } catch (e) { console.error(e) } } #p() { this.polyline && this.map.removeLayer(this.polyline), this.polygon && this.map.removeLayer(this.polygon) } static schema(...e) { try { return HtmlComponent.schema({ type: "map", label: "Map", key: "map", input: !0, tag: "single", validateOn: "change", persistence: !0, multiple: !0, validate: { required: !0 } }) } catch (e) { console.error(e) } } static get builderInfo() { try { return { title: "Map", icon: "geo-alt-fill", group: "basic", documentation: "/userguide/#textfield", weight: 0, schema: MapComponent.schema() } } catch (e) { console.error(e) } } } MapComponent.editForm = (...e) => { try { const t = HtmlComponent.editForm(...e), r = Formio.Utils.getComponent(t.components, "tag"); return r.type = "select", r.dataSrc = "values", r.data = { values: [{ label: "Single", value: "single" }, { label: "Multiple", value: "multiple" }] }, t } catch (e) { console.error(e) } }, Formio.Components.addComponent("map", MapComponent);